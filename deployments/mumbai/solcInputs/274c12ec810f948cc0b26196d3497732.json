{
  "language": "Solidity",
  "sources": {
    "contracts/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n\n"
    },
    "contracts/CampaignContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract CampaignContract {\n\n    struct Campaign {\n        address payable owner;\n        uint256 goal;\n        uint256 deadline;\n        uint256 amount;\n        uint256 participants;\n        bool active;\n    }\n\n\n    function create(Campaign memory campaign) public {\n\n    }\n\n\n    function participate(uint256 campaignId) payable public {\n\n    }\n\n\n\n}"
    },
    "contracts/Comet.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface Comet {\n  function baseScale() external view returns (uint);\n  function supply(address asset, uint amount) external;\n  function withdraw(address asset, uint amount) external;\n\n  function getSupplyRate(uint utilization) external view returns (uint);\n  function getBorrowRate(uint utilization) external view returns (uint);\n\n  function baseTokenPriceFeed() external view returns (address);\n\n  function numAssets() external view returns (uint8);\n\n  function getUtilization() external view returns (uint);\n\n  function baseTrackingSupplySpeed() external view returns (uint);\n  function baseTrackingBorrowSpeed() external view returns (uint);\n\n  function totalSupply() external view returns (uint256);\n  function totalBorrow() external view returns (uint256);\n\n  function collateralBalanceOf(address account, address asset) external view returns (uint128);\n\n  function baseIndexScale() external pure returns (uint64);\n}\n"
    },
    "contracts/IWETH9.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n    function totalSupply() external view returns (uint);\n    function approve(address guy, uint wad) external returns (bool);\n    function transfer(address dst, uint wad) external returns (bool);\n    function transferFrom(address src, address dst, uint wad) external;\n}\n"
    },
    "contracts/QuadraticFunding.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\nimport \"./Babylonian.sol\";\nimport \"./IWETH9.sol\";\nimport \"./Comet.sol\";\n\npragma solidity ^0.8.0;\n\ncontract QuadraticFunding {\n\n    //TODO: Use OpenZeppelin Ownable\n    address owner;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this.\"\n        );\n        _;\n    }\n\n    modifier onlyContributor() {\n        require(\n            (contributorFlags[msg.sender] & CONTRIBUTOR_WHITELIST) != 0x0,\n            \"Only contributor can call this.\"\n        );\n        _;\n    }\n\n    enum StakingPlatform { OneInch, Compound }\n\n    struct Round {\n        uint256 endProjectApplicationDate;\n        uint256 startRoundDate;\n        uint256 endRoundDate;\n        uint256 matchAmount;\n        StakingPlatform platform;\n    }\n\n    struct Project {\n        address payable owner;\n        string name;\n        uint256 matchedQFFunds;\n        bool active;\n    }\n    \n    //Project array index mapped to nextContributionID index mapped to contributions  \n    mapping(uint256 => mapping(uint256 => Contribution)) contributions;\n    uint256 nextContributionID;\n\n    struct Contribution {\n        address contributor;\n        uint256 amount;\n    }\n\n    mapping(address => uint128) public contributorFlags;\n    uint128 internal constant CONTRIBUTOR_WHITELIST = 0x1;\n    uint128 internal constant CONTRIBUTOR_CONTRIBUTED = 0x2;\n\n    Round public currentRound;\n    Project[] projects;\n    mapping(address => uint) projectIndexMap;\n\n    address public COMPOUND_COMET_ADDRESS;\n    address public ONEINCH_ADDRESS;\n    address public WETH_ADDRESS;\n\n    //Podium Round\n    struct PodiumRound {\n        uint256 endRoundDate;\n    }\n\n    //Project index => \n    //Replace string[20] with mapping(uint => string) if needed, then make mapping for\n    mapping(uint256 => mapping(uint => string)) public projectIPFSHashes;\n    //project index => nextIPFSHashID\n    mapping(uint256 => uint256) public projectNextIPFSHashIDs;\n    \n    PodiumRound currentPodiumRound;\n    //Mapped Project indexes to votes\n    mapping(uint => uint) public podiumVotes;\n\n    constructor(address _compoundCometAddress, address _oneInchAddress, address _wethAddress) {\n        COMPOUND_COMET_ADDRESS = _compoundCometAddress;\n        ONEINCH_ADDRESS = _oneInchAddress;\n        WETH_ADDRESS = _wethAddress;\n    }\n\n    function createRound(uint256 _endProjectApplicationDate, uint256 _startRoundDate, uint256 _endRoundDate, StakingPlatform _platform) external payable onlyOwner {\n//        require(block.timestamp > currentRound.endRoundDate, \"QuadraticFunding: Current round must end for new one to begin.\");\n        currentRound = Round(_endProjectApplicationDate, _startRoundDate, _endRoundDate, msg.value, _platform);\n        //TODO: Send to 1inch or Compound for staking\n        if(_platform == StakingPlatform.OneInch) {\n        \n        } else if (_platform == StakingPlatform.Compound) {            \n            IWETH9 weth = IWETH9(WETH_ADDRESS);\n            weth.deposit{value: msg.value}();\n            weth.approve(COMPOUND_COMET_ADDRESS, msg.value);\n            Comet c = Comet(COMPOUND_COMET_ADDRESS);\n            c.supply(WETH_ADDRESS, msg.value);\n        }\n    }\n\n    /**\n     * Note: We assume the sign of a bad round is just based on endRoundDate\n     */\n    function deleteRound() external onlyOwner {\n        require(block.timestamp > currentRound.endRoundDate, \"QuadraticFunding: Current round cannot be removed.\");\n        currentRound.endRoundDate = uint256(0);\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function createProject(string memory _name) external returns (uint256 projectIndex) {\n//        require(block.timestamp < currentRound.endProjectApplicationDate, \"QuadraticFunding: Project application time must be active\");\n        projects.push(Project(payable(msg.sender), _name, 0, true));\n        projectIndex = projects.length - 1;\n        projectIndexMap[msg.sender] = projectIndex;\n    }\n\n    function whitelistContributor(address contributor) external onlyOwner {\n        contributorFlags[contributor] |= CONTRIBUTOR_WHITELIST;\n    }\n\n    function revokeWhitelistContributor(address contributor) external onlyOwner {\n        contributorFlags[contributor] &= ~(CONTRIBUTOR_WHITELIST);\n    }\n\n    function contribute(uint256 projectIndex) external payable onlyContributor {\n//        require(block.timestamp > currentRound.startRoundDate, \"QuadraticFunding: Round must be active\");\n//        require(block.timestamp < currentRound.endRoundDate, \"QuadraticFunding: Round cannot be expired\");\n        require((contributorFlags[msg.sender] & CONTRIBUTOR_CONTRIBUTED) != 0, \"QuadraticFunding: Contributer already submitted contribution\");\n\n        contributions[projectIndex][nextContributionID++] = Contribution(msg.sender, msg.value);\n        projects[projectIndex].owner.transfer(msg.value);\n        contributorFlags[msg.sender] |= CONTRIBUTOR_CONTRIBUTED;\n    }\n\n    // After this function is called, we should have extra kept in the staking contract\n    function quadraticFunding() external {\n//        require(block.timestamp > currentRound.endRoundDate, \"QuadraticFunding: Round has not ended yet\");\n        //Need to add something here to ensure it can't be called twice, e.g. bool\n        if(currentRound.platform == StakingPlatform.OneInch) {\n\n        } else if(currentRound.platform == StakingPlatform.Compound) {\n            Comet c = Comet(COMPOUND_COMET_ADDRESS);\n            uint amount = currentRound.matchAmount;\n            c.withdraw(WETH_ADDRESS, amount);\n            IWETH9 weth = IWETH9(WETH_ADDRESS);\n            weth.withdraw(amount);\n        } \n\n        //Used as holding proportions, later transformed into funding amount\n        uint[] memory proportions = new uint[](projects.length);\n        uint proportionSum = 0;\n        for(uint i = 0; i < projects.length; ++i) {\n            proportions[i] = _quadraticFundingMath(i);\n            proportionSum += proportions[i];\n        }\n        //Finally, calculate funding amounts and distribute\n        for(uint i = 0; i < projects.length; ++i) {\n            projects[i].owner.transfer((currentRound.matchAmount * proportions[i])/proportionSum);\n        }\n    }\n\n    function _quadraticFundingMath(uint pidx) internal view returns (uint) {\n        uint sum = 0;\n        for(uint i = 0; i < nextContributionID; ++i) {\n            sum += Babylonian.sqrt(contributions[pidx][i].amount);\n        }\n        return sum * sum;\n    }\n\n    //Create PodiumRound(done by owner)\n    //uploadResults(string[] results) (get from msg.sender which we can use projectIndexMap to get the index and then associate that with the ipfsHashes)\n\n    function createPodiumRound(uint _endRoundDate) public onlyOwner {\n        currentPodiumRound = PodiumRound(_endRoundDate);\n    }\n\n    function uploadResults(string[] memory _ipfsHashes) public {\n        uint projectIndex = projectIndexMap[msg.sender];\n        for(uint i = 0; i < _ipfsHashes.length; ++i) {\n            projectIPFSHashes[projectIndex][projectNextIPFSHashIDs[projectIndex]++] = _ipfsHashes[i];\n        }\n    }\n\n    function podiumVote(uint projectIndex) public {\n        ++podiumVotes[projectIndex];\n    }\n\n    //distributePodiumPrizes() 0. Pull the total amount of staked ETH from platform, withdraw all from platform, withdraw all from WETH. 1. Calculate all podiumVotes for each project, 2. Calculate the sum of podiumVotes, 3. Calculate each prize winnings by multiplying votes * total prize winnings / sum of podium Votes and distribute that amount\n    function distributePodiumPrizes() public {\n        uint128 amount;\n        if(currentRound.platform == StakingPlatform.OneInch) {\n        \n        } else if(currentRound.platform == StakingPlatform.Compound) {\n            Comet c = Comet(COMPOUND_COMET_ADDRESS);\n            amount = c.collateralBalanceOf(address(this), WETH_ADDRESS);\n            Comet(COMPOUND_COMET_ADDRESS).withdraw(WETH_ADDRESS, amount);\n        }\n        uint sumPodiumVotes = 0;\n        for(uint i = 0; i < projects.length; ++i) {\n            sumPodiumVotes += podiumVotes[i];\n        }\n\n        for(uint i = 0; i < projects.length; ++i) {\n            projects[i].owner.transfer((podiumVotes[i] * amount)/sumPodiumVotes);\n        }\n    }\n\n    //Projects ended, apply quadratic funding on matching amount\n      //Retrieve from 1inch or Compound for payment\n      //Replace in 1inch or Compound for staking the stake\n    //3 month period - Podium Round, perform the same round\n      //Straight vote; allocates proportion of votes percentage-based\n    //Finally, withdraw staked stake in proportion to voters\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}